---
layout: essay
type: essay
title: "Principle But Not Law"
# All dates must be YYYY-MM-DD format!
date: 2025-04-25
published: true
labels:
  - Design Patterns
  - Software Engineering
---

<img width="100px" class="rounded float-start pe-4" src="../img/s-l1200.jpg">

Growing up, when Christmas came around, I would often ask for LEGOs, as I always enjoyed building them then using the extra pieces to build something different altogether. At first I would just mess around, building random things that weren't quite good loooking nor sturdy enough to withstand being placed in a bin when I finished playing with it. However, over time I grew to realize that there were building principles that although weren't mandated by any means, helped significantly improve the quality of the gizmos I built. From building lining up pieces in different ways to using more sturdy joints to connect pieces, these ideas helped my LEGO creations live a little longer in the mess that was my LEGO bin.

This idea is the same one behind software design patterns, as design patterns act not as blueprints or instructions on how to develop software but instead as reusable solutions to problems you might encounter, just like those I applied to my LEGOs through trial and experience. They arenâ€™t meant to solve every problem, but when you spot a familiar scenario, a design pattern can offer a time-tested way to decipher and solve the issue at hand.

Through most of my time programming, I haven't thought about using design patterns, as I didn't necessarily know what they were until quite recently. However, there are certain design patterns that creep there way into our programs without us even knowing, such as the Singleton pattern and the factory method design pattern. Using these patterns help standardize and create programs that not only don't suffer from the issues these design patterns are meant to handle but also easily tackle known issues that they might come upon. The design pattern I use most often, however, is the observer pattern, which handles the issue of "observer" objects needing to be informed of changes to the state of the "subject" object. This pattern provides a known pattern to writing programs that need to address this issue, which is common among many mid-level programs.
